{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-image-lightbox.js","webpack:///webpack/bootstrap 28d70775e6f449cdc3e0","webpack:///./src/index.js","webpack:///./src/constant.js","webpack:///./src/react-image-lightbox.js","webpack:///./src/util.js","webpack:///external \"react\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","MIN_ZOOM_LEVEL","MAX_ZOOM_LEVEL","ZOOM_RATIO","ZOOM_BUTTON_INCREMENT_SIZE","WHEEL_MOVE_X_THRESHOLD","WHEEL_MOVE_Y_THRESHOLD","KEYS","ESC","LEFT_ARROW","RIGHT_ARROW","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","_defineProperty","key","_styles","_extends","assign","target","i","arguments","length","source","hasOwnProperty","_createClass","defineProperties","props","descriptor","protoProps","staticProps","_react","_react2","_util","_constant","styles","builtinButtonDisabled","builtinButton","closeButton","closeWindow","ReactImageLightbox","_Component","_this","getPrototypeOf","state","isClosing","animationDisabled","shouldAnimate","zoomLevel","offsetX","offsetY","closeIfClickInner","bind","handleImageDoubleClick","handleImageMouseWheel","handleKeyInput","handleMouseUp","handleOuterMouseDown","handleOuterMouseMove","handleOuterMousewheel","handleOuterTouchStart","handleOuterTouchMove","handleWindowResize","handleZoomInButtonClick","handleZoomOutButtonClick","requestClose","requestMoveNext","requestMovePrev","listenersAttached","keyPressed","imageCache","lastKeyDownTime","resizeTimeout","wheelActionTimeout","resetScrollTimeout","scrollX","scrollY","isDragging","dragStartX","dragStartY","dragStartOffsetX","dragStartOffsetY","keyCounter","moveRequested","setState","attachListeners","loadAllImages","nextProps","_this2","sourcesChanged","getSrcTypes","some","srcType","name","detachListeners","document","addEventListener","window","isInIframe","top","clientX","clientY","windowWidth","getWindowWidth","windowHeight","getWindowHeight","nextZoomLevel","Math","max","min","currentZoomMultiplier","getZoomMultiplier","nextZoomMultiplier","percentXInCurrentBox","percentYInCurrentBox","currentBoxWidth","currentBoxHeight","nextBoxWidth","nextBoxHeight","deltaX","deltaY","nextOffsetX","nextOffsetY","maxOffsets","getMaxOffsets","minX","maxX","minY","maxY","event","className","search","removeEventListener","imageSrc","fitSizes","isImageLoaded","getFitSizes","width","height","src","stretch","maxHeight","imagePadding","maxWidth","maxRatio","srcRatio","undefined","currentImageInfo","getBestImageForType","zoomMultiplier","x","y","keyEnding","pow","stopPropagation","isAnimating","type","keyRepeatKeyupBonus","keyCode","which","currentTime","Date","getTime","keyRepeatLimit","preventDefault","prevSrc","nextSrc","_this3","xThreshold","actionDelay","imageMoveDelay","clearTimeout","setTimeout","abs","bigLeapX","yThreshold","changeZoom","_this4","animationDuration","handleMoveStart","touchObj","changedTouches","parseInt","newOffsetX","newOffsetY","handleMove","forceUpdate","callback","_this5","that","inMemoryImage","Image","onerror","onload","_this6","generateImageLoadedCallback","err","console","warn","forEach","loadImage","_this7","closeLightbox","onCloseRequest","animationOnKeyInput","direction","_this8","nextState","onMovePrevRequest","onMoveNextRequest","requestMove","_this9","transitionStyle","transition","map","join","keyEndings","_ref","images","addImage","imageClass","baseStyle","imageStyle","cursor","bestImageInfo","push","createElement","image","style","discourageDownloads","backgroundImage","imageDiscourager","onDoubleClick","onWheel","alt","imageTitle","translate","imageNext","transform","left","right","bottom","imagePrev","noop","zoomInButtonClasses","toolbarItemChild","zoomInButton","zoomOutButtonClasses","zoomOutButton","zoomInButtonHandler","zoomOutButtonHandler","onMouseMove","onMouseDown","onTouchStart","onTouchMove","outer","outerAnimating","outerClosing","animationDirection","inner","onClick","clickOutsideToClose","navButtons","navButtonPrev","navButtonNext","toolbar","toolbarSide","toolbarLeftSide","toolbarItem","toolbarRightSide","toolbarButtons","button","Component","propTypes","mainSrc","PropTypes","string","isRequired","mainSrcThumbnail","prevSrcThumbnail","nextSrcThumbnail","func","bool","number","node","arrayOf","defaultProps","getIEVersion","match","navigator","userAgent","str","replaceStrings","translated","keys","placeholder","replace","innerWidth","documentElement","clientWidth","body","innerHeight","clientHeight","e"],"mappings":"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","file":"react-image-lightbox.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactImageLightbox\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactImageLightbox\"] = factory(root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactImageLightbox\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactImageLightbox\"] = factory(root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tmodule.exports = __webpack_require__(2).default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t// Min image zoom level\n\tvar MIN_ZOOM_LEVEL = exports.MIN_ZOOM_LEVEL = 0;\n\t\n\t// Max image zoom level\n\tvar MAX_ZOOM_LEVEL = exports.MAX_ZOOM_LEVEL = 300;\n\t\n\t// Size ratio between previous and next zoom levels\n\tvar ZOOM_RATIO = exports.ZOOM_RATIO = 1.007;\n\t\n\t// How much to increase/decrease the zoom level when the zoom buttons are clicked\n\tvar ZOOM_BUTTON_INCREMENT_SIZE = exports.ZOOM_BUTTON_INCREMENT_SIZE = 100;\n\t\n\t// Used to judge the amount of horizontal scroll needed to initiate a image move\n\tvar WHEEL_MOVE_X_THRESHOLD = exports.WHEEL_MOVE_X_THRESHOLD = 200;\n\t\n\t// Used to judge the amount of vertical scroll needed to initiate a zoom action\n\tvar WHEEL_MOVE_Y_THRESHOLD = exports.WHEEL_MOVE_Y_THRESHOLD = 1;\n\t\n\tvar KEYS = exports.KEYS = {\n\t    ESC: 27,\n\t    LEFT_ARROW: 37,\n\t    RIGHT_ARROW: 39\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _styles;\n\t\n\tvar _react = __webpack_require__(5);\n\t\n\tvar _react2 = _interopRequireDefault(_react);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _constant = __webpack_require__(1);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; } /*\n\t                                                                                                                                                                                                                   * react-image-lightbox\n\t                                                                                                                                                                                                                   * Copyright 2016 Chris Fritz All rights reserved.\n\t                                                                                                                                                                                                                   * @license Open source under the MIT License\n\t                                                                                                                                                                                                                   */\n\t\n\t//import Modal from 'react-modal';\n\t\n\t\n\t__webpack_require__(4);\n\t\n\t// Add fallback classes for browsers without flexbox support\n\tvar styles = (_styles = { \"builtinButtonDisabled\": \"builtinButtonDisabled_rilu\",\n\t    \"builtinButton\": \"builtinButton_rilu\",\n\t    \"closeButton\": \"closeButton_rilu\",\n\t    \"closeWindow\": \"closeWindow_rilu\"\n\t}, _defineProperty(_styles, 'closeWindow', \"closeWindow_rilu\"), _defineProperty(_styles, \"downloadBlocker\", \"downloadBlocker_rilu\"), _defineProperty(_styles, \"imageDiscourager\", \"imageDiscourager_rilu\"), _defineProperty(_styles, \"imageNext\", \"imageNext_rilu\"), _defineProperty(_styles, \"imagePrev\", \"imagePrev_rilu\"), _defineProperty(_styles, \"image\", \"image_rilu\"), _defineProperty(_styles, \"inner\", \"inner_rilu\"), _defineProperty(_styles, \"navButtonNext\", \"navButtonNext_rilu\"), _defineProperty(_styles, \"navButtonPrev\", \"navButtonPrev_rilu\"), _defineProperty(_styles, \"navButtons\", \"navButtons_rilu\"), _defineProperty(_styles, \"outerAnimating\", \"outerAnimating_rilu\"), _defineProperty(_styles, \"outerClosing\", \"outerClosing_rilu\"), _defineProperty(_styles, \"outer\", \"outer_rilu\"), _defineProperty(_styles, \"toolbarItemChild\", \"toolbarItemChild_rilu\"), _defineProperty(_styles, \"toolbarItem\", \"toolbarItem_rilu\"), _defineProperty(_styles, \"toolbarLeftSideNoFlex\", \"toolbarLeftSideNoFlex_rilu\"), _defineProperty(_styles, \"toolbarLeftSide\", \"toolbarLeftSide_rilu\"), _defineProperty(_styles, \"toolbarRightSideNoFlex\", \"toolbarRightSideNoFlex_rilu\"), _defineProperty(_styles, \"toolbarRightSide\", \"toolbarRightSide_rilu\"), _defineProperty(_styles, \"toolbarSideNoFlex\", \"toolbarSideNoFlex_rilu\"), _defineProperty(_styles, \"toolbarSide\", \"toolbarSide_rilu\"), _defineProperty(_styles, \"toolbar\", \"toolbar_rilu\"), _defineProperty(_styles, \"zoomInButton\", \"zoomInButton_rilu\"), _defineProperty(_styles, \"zoomOutButton\", \"zoomOutButton_rilu\"), _styles);\n\t/**if (getIEVersion() < 10) {\n\t    styles = {\n\t        ...styles,\n\t        toolbarSide:      `${styles.toolbarSide} ${styles.toolbarSideNoFlex}`,\n\t        toolbarLeftSide:  `${styles.toolbarLeftSide} ${styles.toolbarLeftSideNoFlex}`,\n\t        toolbarRightSide: `${styles.toolbarRightSide} ${styles.toolbarRightSideNoFlex}`,\n\t    };\n\t}**/\n\t\n\tvar ReactImageLightbox = function (_Component) {\n\t    _inherits(ReactImageLightbox, _Component);\n\t\n\t    function ReactImageLightbox(props) {\n\t        _classCallCheck(this, ReactImageLightbox);\n\t\n\t        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ReactImageLightbox).call(this, props));\n\t\n\t        _this.state = {\n\t            //-----------------------------\n\t            // Animation\n\t            //-----------------------------\n\t\n\t            // Lightbox is closing\n\t            // When Lightbox is mounted, if animation is enabled it will open with the reverse of the closing animation\n\t            isClosing: !props.animationDisabled,\n\t\n\t            // Component parts should animate (e.g., when images are moving, or image is being zoomed)\n\t            shouldAnimate: false,\n\t\n\t            //-----------------------------\n\t            // Zoom settings\n\t            //-----------------------------\n\t            // Zoom level of image\n\t            zoomLevel: _constant.MIN_ZOOM_LEVEL,\n\t\n\t            //-----------------------------\n\t            // Image position settings\n\t            //-----------------------------\n\t            // Horizontal offset from center\n\t            offsetX: 0,\n\t\n\t            // Vertical offset from center\n\t            offsetY: 0\n\t        };\n\t\n\t        _this.closeIfClickInner = _this.closeIfClickInner.bind(_this);\n\t        _this.handleImageDoubleClick = _this.handleImageDoubleClick.bind(_this);\n\t        _this.handleImageMouseWheel = _this.handleImageMouseWheel.bind(_this);\n\t        _this.handleKeyInput = _this.handleKeyInput.bind(_this);\n\t        _this.handleMouseUp = _this.handleMouseUp.bind(_this);\n\t        _this.handleOuterMouseDown = _this.handleOuterMouseDown.bind(_this);\n\t        _this.handleOuterMouseMove = _this.handleOuterMouseMove.bind(_this);\n\t        _this.handleOuterMousewheel = _this.handleOuterMousewheel.bind(_this);\n\t        _this.handleOuterTouchStart = _this.handleOuterTouchStart.bind(_this);\n\t        _this.handleOuterTouchMove = _this.handleOuterTouchMove.bind(_this);\n\t        _this.handleWindowResize = _this.handleWindowResize.bind(_this);\n\t        _this.handleZoomInButtonClick = _this.handleZoomInButtonClick.bind(_this);\n\t        _this.handleZoomOutButtonClick = _this.handleZoomOutButtonClick.bind(_this);\n\t        _this.requestClose = _this.requestClose.bind(_this);\n\t        _this.requestMoveNext = _this.requestMoveNext.bind(_this);\n\t        _this.requestMovePrev = _this.requestMovePrev.bind(_this);\n\t        return _this;\n\t    }\n\t\n\t    _createClass(ReactImageLightbox, [{\n\t        key: 'componentWillMount',\n\t        value: function componentWillMount() {\n\t            // Whether event listeners for keyboard and mouse input have been attached or not\n\t            this.listenersAttached = false;\n\t\n\t            // Used to disable animation when changing props.mainSrc|nextSrc|prevSrc\n\t            this.keyPressed = false;\n\t\n\t            // Used to store load state / dimensions of images\n\t            this.imageCache = {};\n\t\n\t            // Time the last keydown event was called (used in keyboard action rate limiting)\n\t            this.lastKeyDownTime = 0;\n\t\n\t            // Used for debouncing window resize event\n\t            this.resizeTimeout = null;\n\t\n\t            // Used to determine when actions are triggered by the scroll wheel\n\t            this.wheelActionTimeout = null;\n\t            this.resetScrollTimeout = null;\n\t            this.scrollX = 0;\n\t            this.scrollY = 0;\n\t\n\t            // Used in panning zoomed images\n\t            this.isDragging = false;\n\t            this.dragStartX = 0;\n\t            this.dragStartY = 0;\n\t            this.dragStartOffsetX = 0;\n\t            this.dragStartOffsetY = 0;\n\t\n\t            // Used to differentiate between images with identical src\n\t            this.keyCounter = 0;\n\t\n\t            // Used to detect a move when all src's remain unchanged (four or more of the same image in a row)\n\t            this.moveRequested = false;\n\t\n\t            if (!this.props.animationDisabled) {\n\t                // Make opening animation play\n\t                this.setState({ isClosing: false });\n\t            }\n\t        }\n\t    }, {\n\t        key: 'componentDidMount',\n\t        value: function componentDidMount() {\n\t            this.attachListeners();\n\t\n\t            this.loadAllImages();\n\t        }\n\t    }, {\n\t        key: 'componentWillReceiveProps',\n\t        value: function componentWillReceiveProps(nextProps) {\n\t            var _this2 = this;\n\t\n\t            var sourcesChanged = this.getSrcTypes().some(function (srcType) {\n\t                return _this2.props[srcType.name] !== nextProps[srcType.name];\n\t            });\n\t\n\t            if (sourcesChanged || this.moveRequested) {\n\t                this.moveRequested = false;\n\t\n\t                // Load any new images\n\t                this.loadAllImages(nextProps);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'componentWillUnmount',\n\t        value: function componentWillUnmount() {\n\t            this.detachListeners();\n\t        }\n\t\n\t        // Attach key and mouse input events\n\t\n\t    }, {\n\t        key: 'attachListeners',\n\t        value: function attachListeners() {\n\t            if (!this.listenersAttached) {\n\t                document.addEventListener('keydown', this.handleKeyInput);\n\t                document.addEventListener('keyup', this.handleKeyInput);\n\t                window.addEventListener('resize', this.handleWindowResize);\n\t                window.addEventListener('mouseup', this.handleMouseUp);\n\t                window.addEventListener('touchend', this.handleMouseUp);\n\t\n\t                // Have to add an extra mouseup handler to catch mouseup events outside of the window\n\t                //  if the page containing the lightbox is displayed in an iframe\n\t                if ((0, _util.isInIframe)()) {\n\t                    window.top.addEventListener('mouseup', this.handleMouseUp);\n\t                    window.top.addEventListener('touchend', this.handleMouseUp);\n\t                }\n\t\n\t                this.listenersAttached = true;\n\t            }\n\t        }\n\t\n\t        // Change zoom level\n\t\n\t    }, {\n\t        key: 'changeZoom',\n\t        value: function changeZoom(zoomLevel, clientX, clientY) {\n\t            var windowWidth = (0, _util.getWindowWidth)();\n\t            var windowHeight = (0, _util.getWindowHeight)();\n\t\n\t            // Constrain zoom level to the set bounds\n\t            var nextZoomLevel = Math.max(_constant.MIN_ZOOM_LEVEL, Math.min(_constant.MAX_ZOOM_LEVEL, zoomLevel));\n\t\n\t            // Ignore requests that don't change the zoom level\n\t            if (nextZoomLevel === this.state.zoomLevel) {\n\t                return;\n\t            } else if (nextZoomLevel === _constant.MIN_ZOOM_LEVEL) {\n\t                // Snap back to center if zoomed all the way out\n\t                return this.setState({\n\t                    zoomLevel: nextZoomLevel,\n\t                    offsetX: 0,\n\t                    offsetY: 0\n\t                });\n\t            }\n\t\n\t            var currentZoomMultiplier = this.getZoomMultiplier();\n\t            var nextZoomMultiplier = this.getZoomMultiplier(nextZoomLevel);\n\t\n\t            // Default to the center of the screen to zoom when no mouse position specified\n\t            var percentXInCurrentBox = (typeof clientX !== 'undefined' ? clientX : windowWidth / 2) / windowWidth;\n\t            var percentYInCurrentBox = (typeof clientY !== 'undefined' ? clientY : windowHeight / 2) / windowHeight;\n\t\n\t            var currentBoxWidth = windowWidth / currentZoomMultiplier;\n\t            var currentBoxHeight = windowHeight / currentZoomMultiplier;\n\t\n\t            var nextBoxWidth = windowWidth / nextZoomMultiplier;\n\t            var nextBoxHeight = windowHeight / nextZoomMultiplier;\n\t\n\t            var deltaX = (nextBoxWidth - currentBoxWidth) * (percentXInCurrentBox - 0.5);\n\t            var deltaY = (nextBoxHeight - currentBoxHeight) * (percentYInCurrentBox - 0.5);\n\t\n\t            var nextOffsetX = this.state.offsetX - deltaX;\n\t            var nextOffsetY = this.state.offsetY - deltaY;\n\t\n\t            // When zooming out, limit the offset so things don't get left askew\n\t            var maxOffsets = this.getMaxOffsets();\n\t            if (this.state.zoomLevel > nextZoomLevel) {\n\t                nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, nextOffsetX));\n\t                nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, nextOffsetY));\n\t            }\n\t\n\t            this.setState({\n\t                zoomLevel: nextZoomLevel,\n\t                offsetX: nextOffsetX,\n\t                offsetY: nextOffsetY\n\t            });\n\t        }\n\t    }, {\n\t        key: 'closeIfClickInner',\n\t        value: function closeIfClickInner(event) {\n\t            if (event.target.className.search(/\\binner\\b/) > -1) {\n\t                this.requestClose(event);\n\t            }\n\t        }\n\t\n\t        // Detach key and mouse input events\n\t\n\t    }, {\n\t        key: 'detachListeners',\n\t        value: function detachListeners() {\n\t            if (this.listenersAttached) {\n\t                document.removeEventListener('keydown', this.handleKeyInput);\n\t                document.removeEventListener('keyup', this.handleKeyInput);\n\t                window.removeEventListener('resize', this.handleWindowResize);\n\t                window.removeEventListener('mouseup', this.handleMouseUp);\n\t                window.removeEventListener('touchend', this.handleMouseUp);\n\t\n\t                if ((0, _util.isInIframe)()) {\n\t                    window.top.removeEventListener('mouseup', this.handleMouseUp);\n\t                    window.top.removeEventListener('touchend', this.handleMouseUp);\n\t                }\n\t\n\t                this.listenersAttached = false;\n\t            }\n\t        }\n\t\n\t        // Get info for the best suited image to display with the given srcType\n\t\n\t    }, {\n\t        key: 'getBestImageForType',\n\t        value: function getBestImageForType(srcType) {\n\t            var imageSrc = this.props[srcType];\n\t            var fitSizes = {};\n\t\n\t            if (this.isImageLoaded(imageSrc)) {\n\t                // Use full-size image if available\n\t                fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height);\n\t            } else if (this.isImageLoaded(this.props[srcType + 'Thumbnail'])) {\n\t                // Fall back to using thumbnail if the image has not been loaded\n\t                imageSrc = this.props[srcType + 'Thumbnail'];\n\t                fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height, true);\n\t            } else {\n\t                return null;\n\t            }\n\t\n\t            return {\n\t                src: imageSrc,\n\t                height: fitSizes.height,\n\t                width: fitSizes.width\n\t            };\n\t        }\n\t\n\t        // Get sizing for when an image is larger than the window\n\t\n\t    }, {\n\t        key: 'getFitSizes',\n\t        value: function getFitSizes(width, height, stretch) {\n\t            var windowHeight = (0, _util.getWindowHeight)();\n\t            var windowWidth = (0, _util.getWindowWidth)();\n\t            var maxHeight = windowHeight - this.props.imagePadding * 2;\n\t            var maxWidth = windowWidth - this.props.imagePadding * 2;\n\t\n\t            if (!stretch) {\n\t                maxHeight = Math.min(maxHeight, height);\n\t                maxWidth = Math.min(maxWidth, width);\n\t            }\n\t\n\t            var maxRatio = maxWidth / maxHeight;\n\t            var srcRatio = width / height;\n\t\n\t            var fitSizes = {};\n\t            if (maxRatio > srcRatio) {\n\t                // height is the constraining dimension of the photo\n\t                fitSizes.width = width * maxHeight / height;\n\t                fitSizes.height = maxHeight;\n\t            } else {\n\t                fitSizes.width = maxWidth;\n\t                fitSizes.height = height * maxWidth / width;\n\t            }\n\t\n\t            return fitSizes;\n\t        }\n\t    }, {\n\t        key: 'getMaxOffsets',\n\t        value: function getMaxOffsets() {\n\t            var zoomLevel = arguments.length <= 0 || arguments[0] === undefined ? this.state.zoomLevel : arguments[0];\n\t\n\t            var currentImageInfo = this.getBestImageForType('mainSrc');\n\t            if (currentImageInfo === null) {\n\t                return { maxX: 0, minX: 0, maxY: 0, minY: 0 };\n\t            }\n\t\n\t            var windowWidth = (0, _util.getWindowWidth)();\n\t            var windowHeight = (0, _util.getWindowHeight)();\n\t            var zoomMultiplier = this.getZoomMultiplier(zoomLevel);\n\t\n\t            var maxX = 0;\n\t            if (currentImageInfo.width - windowWidth / zoomMultiplier < 0) {\n\t                // if there is still blank space in the X dimension, don't limit except to the opposite edge\n\t                maxX = (windowWidth / zoomMultiplier - currentImageInfo.width) / 2;\n\t            } else {\n\t                maxX = (currentImageInfo.width - windowWidth / zoomMultiplier) / 2;\n\t            }\n\t\n\t            var maxY = 0;\n\t            if (currentImageInfo.height - windowHeight / zoomMultiplier < 0) {\n\t                // if there is still blank space in the Y dimension, don't limit except to the opposite edge\n\t                maxY = (windowHeight / zoomMultiplier - currentImageInfo.height) / 2;\n\t            } else {\n\t                maxY = (currentImageInfo.height - windowHeight / zoomMultiplier) / 2;\n\t            }\n\t\n\t            return {\n\t                maxX: maxX,\n\t                maxY: maxY,\n\t                minX: -1 * maxX,\n\t                minY: -1 * maxY\n\t            };\n\t        }\n\t    }, {\n\t        key: 'getOffsetXFromWindowCenter',\n\t        value: function getOffsetXFromWindowCenter(x) {\n\t            var windowWidth = (0, _util.getWindowWidth)();\n\t            return windowWidth / 2 - x;\n\t        }\n\t    }, {\n\t        key: 'getOffsetYFromWindowCenter',\n\t        value: function getOffsetYFromWindowCenter(y) {\n\t            var windowHeight = (0, _util.getWindowHeight)();\n\t            return windowHeight / 2 - y;\n\t        }\n\t\n\t        // Get image src types\n\t\n\t    }, {\n\t        key: 'getSrcTypes',\n\t        value: function getSrcTypes() {\n\t            return [{\n\t                name: 'mainSrc',\n\t                keyEnding: 'i' + this.keyCounter\n\t            }, {\n\t                name: 'mainSrcThumbnail',\n\t                keyEnding: 't' + this.keyCounter\n\t            }, {\n\t                name: 'nextSrc',\n\t                keyEnding: 'i' + (this.keyCounter + 1)\n\t            }, {\n\t                name: 'nextSrcThumbnail',\n\t                keyEnding: 't' + (this.keyCounter + 1)\n\t            }, {\n\t                name: 'prevSrc',\n\t                keyEnding: 'i' + (this.keyCounter - 1)\n\t            }, {\n\t                name: 'prevSrcThumbnail',\n\t                keyEnding: 't' + (this.keyCounter - 1)\n\t            }];\n\t        }\n\t\n\t        // Get sizing when the image is scaled\n\t\n\t    }, {\n\t        key: 'getZoomMultiplier',\n\t        value: function getZoomMultiplier() {\n\t            var zoomLevel = arguments.length <= 0 || arguments[0] === undefined ? this.state.zoomLevel : arguments[0];\n\t\n\t            return Math.pow(_constant.ZOOM_RATIO, zoomLevel);\n\t        }\n\t\n\t        // Handle user keyboard actions\n\t\n\t    }, {\n\t        key: 'handleKeyInput',\n\t        value: function handleKeyInput(event) {\n\t            event.stopPropagation();\n\t\n\t            // Ignore key input during animations\n\t            if (this.isAnimating()) {\n\t                return;\n\t            }\n\t\n\t            // Allow slightly faster navigation through the images when user presses keys repeatedly\n\t            if (event.type === 'keyup') {\n\t                this.lastKeyDownTime -= this.props.keyRepeatKeyupBonus;\n\t                return;\n\t            }\n\t\n\t            var keyCode = event.which || event.keyCode;\n\t\n\t            // Ignore key presses that happen too close to each other (when rapid fire key pressing or holding down the key)\n\t            // But allow it if it's a lightbox closing action\n\t            var currentTime = new Date();\n\t            if (currentTime.getTime() - this.lastKeyDownTime < this.props.keyRepeatLimit && keyCode !== _constant.KEYS.ESC) {\n\t                return;\n\t            }\n\t            this.lastKeyDownTime = currentTime.getTime();\n\t\n\t            switch (keyCode) {\n\t                // ESC key closes the lightbox\n\t                case _constant.KEYS.ESC:\n\t                    event.preventDefault();\n\t                    this.requestClose(event);\n\t                    break;\n\t\n\t                // Left arrow key moves to previous image\n\t                case _constant.KEYS.LEFT_ARROW:\n\t                    if (!this.props.prevSrc) {\n\t                        return;\n\t                    }\n\t\n\t                    event.preventDefault();\n\t                    this.keyPressed = true;\n\t                    this.requestMovePrev(event);\n\t                    break;\n\t\n\t                // Right arrow key moves to next image\n\t                case _constant.KEYS.RIGHT_ARROW:\n\t                    if (!this.props.nextSrc) {\n\t                        return;\n\t                    }\n\t\n\t                    event.preventDefault();\n\t                    this.keyPressed = true;\n\t                    this.requestMoveNext(event);\n\t                    break;\n\t\n\t                default:\n\t            }\n\t        }\n\t\n\t        // Handle a mouse wheel event over the lightbox container\n\t\n\t    }, {\n\t        key: 'handleOuterMousewheel',\n\t        value: function handleOuterMousewheel(event) {\n\t            var _this3 = this;\n\t\n\t            // Prevent scrolling of the background\n\t            event.preventDefault();\n\t            event.stopPropagation();\n\t\n\t            var xThreshold = _constant.WHEEL_MOVE_X_THRESHOLD;\n\t            var actionDelay = 0;\n\t            var imageMoveDelay = 500;\n\t\n\t            clearTimeout(this.resetScrollTimeout);\n\t            this.resetScrollTimeout = setTimeout(function () {\n\t                _this3.scrollX = 0;\n\t                _this3.scrollY = 0;\n\t            }, 300);\n\t\n\t            // Prevent rapid-fire zoom behavior\n\t            if (this.wheelActionTimeout !== null || this.isAnimating()) {\n\t                return;\n\t            }\n\t\n\t            if (Math.abs(event.deltaY) < Math.abs(event.deltaX)) {\n\t                // handle horizontal scrolls with image moves\n\t                this.scrollY = 0;\n\t                this.scrollX += event.deltaX;\n\t\n\t                var bigLeapX = xThreshold / 2;\n\t                // If the scroll amount has accumulated sufficiently, or a large leap was taken\n\t                if (this.scrollX >= xThreshold || event.deltaX >= bigLeapX) {\n\t                    // Scroll right moves to next\n\t                    this.requestMoveNext(event);\n\t                    actionDelay = imageMoveDelay;\n\t                    this.scrollX = 0;\n\t                } else if (this.scrollX <= -1 * xThreshold || event.deltaX <= -1 * bigLeapX) {\n\t                    // Scroll left moves to previous\n\t                    this.requestMovePrev(event);\n\t                    actionDelay = imageMoveDelay;\n\t                    this.scrollX = 0;\n\t                }\n\t            }\n\t\n\t            // Allow successive actions after the set delay\n\t            if (actionDelay !== 0) {\n\t                this.wheelActionTimeout = setTimeout(function () {\n\t                    _this3.wheelActionTimeout = null;\n\t                }, actionDelay);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'handleImageMouseWheel',\n\t        value: function handleImageMouseWheel(event) {\n\t            event.preventDefault();\n\t            var yThreshold = _constant.WHEEL_MOVE_Y_THRESHOLD;\n\t\n\t            if (Math.abs(event.deltaY) >= Math.abs(event.deltaX)) {\n\t                event.stopPropagation();\n\t                // If the vertical scroll amount was large enough, perform a zoom\n\t                if (Math.abs(event.deltaY) < yThreshold) {\n\t                    return;\n\t                }\n\t\n\t                this.scrollX = 0;\n\t                this.scrollY += event.deltaY;\n\t\n\t                this.changeZoom(this.state.zoomLevel - event.deltaY, event.clientX, event.clientY);\n\t            }\n\t        }\n\t\n\t        // Handle a double click on the current image\n\t\n\t    }, {\n\t        key: 'handleImageDoubleClick',\n\t        value: function handleImageDoubleClick(event) {\n\t            if (this.state.zoomLevel > _constant.MIN_ZOOM_LEVEL) {\n\t                // A double click when zoomed in zooms all the way out\n\t                this.changeZoom(_constant.MIN_ZOOM_LEVEL, event.clientX, event.clientY);\n\t            } else {\n\t                // A double click when zoomed all the way out zooms in\n\t                this.changeZoom(this.state.zoomLevel + _constant.ZOOM_BUTTON_INCREMENT_SIZE, event.clientX, event.clientY);\n\t            }\n\t        }\n\t\n\t        // Handle a mouse click ending in the lightbox container\n\t\n\t    }, {\n\t        key: 'handleMouseUp',\n\t        value: function handleMouseUp() {\n\t            var _this4 = this;\n\t\n\t            if (!this.isDragging) {\n\t                return;\n\t            }\n\t\n\t            this.isDragging = false;\n\t\n\t            // Snap image back into frame if outside max offset range\n\t            var maxOffsets = this.getMaxOffsets();\n\t            var nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, this.state.offsetX));\n\t            var nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, this.state.offsetY));\n\t            if (nextOffsetX !== this.state.offsetX || nextOffsetY !== this.state.offsetY) {\n\t                this.setState({\n\t                    offsetX: nextOffsetX,\n\t                    offsetY: nextOffsetY,\n\t                    shouldAnimate: true\n\t                });\n\t\n\t                setTimeout(function () {\n\t                    _this4.setState({ shouldAnimate: false });\n\t                }, this.props.animationDuration);\n\t            }\n\t        }\n\t\n\t        // Handle move start over the lightbox container\n\t        // This happens:\n\t        // - On a mouseDown event\n\t        // - On a touchstart event\n\t\n\t    }, {\n\t        key: 'handleMoveStart',\n\t        value: function handleMoveStart(clientX, clientY) {\n\t            // Only allow dragging when zoomed\n\t            if (this.state.zoomLevel <= _constant.MIN_ZOOM_LEVEL) {\n\t                return;\n\t            }\n\t\n\t            this.isDragging = true;\n\t            this.dragStartX = clientX;\n\t            this.dragStartY = clientY;\n\t            this.dragStartOffsetX = this.state.offsetX;\n\t            this.dragStartOffsetY = this.state.offsetY;\n\t        }\n\t\n\t        // Handle the mouse clicking down in the lightbox container\n\t\n\t    }, {\n\t        key: 'handleOuterMouseDown',\n\t        value: function handleOuterMouseDown(event) {\n\t            event.preventDefault();\n\t            this.handleMoveStart(event.clientX, event.clientY);\n\t        }\n\t\n\t        // Touch screen version of handleOuterMouseDown()\n\t\n\t    }, {\n\t        key: 'handleOuterTouchStart',\n\t        value: function handleOuterTouchStart(event) {\n\t            var touchObj = event.changedTouches[0];\n\t            this.handleMoveStart(parseInt(touchObj.clientX, 10), parseInt(touchObj.clientY, 10));\n\t        }\n\t\n\t        // Handle dragging over the lightbox container\n\t        // This happens:\n\t        // - After a mouseDown and before a mouseUp event\n\t        // - After a touchstart and before a touchend event\n\t\n\t    }, {\n\t        key: 'handleMove',\n\t        value: function handleMove(clientX, clientY) {\n\t            if (!this.isDragging) {\n\t                return;\n\t            }\n\t\n\t            var zoomMultiplier = this.getZoomMultiplier();\n\t\n\t            var newOffsetX = (this.dragStartX - clientX) / zoomMultiplier + this.dragStartOffsetX;\n\t            var newOffsetY = (this.dragStartY - clientY) / zoomMultiplier + this.dragStartOffsetY;\n\t            if (this.state.offsetX !== newOffsetX || this.state.offsetY !== newOffsetY) {\n\t                this.setState({\n\t                    offsetX: newOffsetX,\n\t                    offsetY: newOffsetY\n\t                });\n\t            }\n\t        }\n\t\n\t        // Handle the mouse dragging over the lightbox container\n\t        // (after a mouseDown and before a mouseUp event)\n\t\n\t    }, {\n\t        key: 'handleOuterMouseMove',\n\t        value: function handleOuterMouseMove(event) {\n\t            this.handleMove(event.clientX, event.clientY);\n\t        }\n\t\n\t        // Touch screen version of handleOuterMouseMove()\n\t\n\t    }, {\n\t        key: 'handleOuterTouchMove',\n\t        value: function handleOuterTouchMove(event) {\n\t            event.preventDefault();\n\t\n\t            // We shouldn't go any further if we're not zoomed\n\t            if (this.state.zoomLevel <= _constant.MIN_ZOOM_LEVEL) {\n\t                return;\n\t            }\n\t\n\t            var touchObj = event.changedTouches[0];\n\t            this.handleMove(parseInt(touchObj.clientX, 10), parseInt(touchObj.clientY, 10));\n\t        }\n\t\n\t        // Handle the window resize event\n\t\n\t    }, {\n\t        key: 'handleWindowResize',\n\t        value: function handleWindowResize() {\n\t            clearTimeout(this.resizeTimeout);\n\t            this.resizeTimeout = setTimeout(this.forceUpdate.bind(this), 100);\n\t        }\n\t    }, {\n\t        key: 'handleZoomInButtonClick',\n\t        value: function handleZoomInButtonClick() {\n\t            this.changeZoom(this.state.zoomLevel + _constant.ZOOM_BUTTON_INCREMENT_SIZE);\n\t        }\n\t    }, {\n\t        key: 'handleZoomOutButtonClick',\n\t        value: function handleZoomOutButtonClick() {\n\t            this.changeZoom(this.state.zoomLevel - _constant.ZOOM_BUTTON_INCREMENT_SIZE);\n\t        }\n\t\n\t        // Detach key and mouse input events\n\t\n\t    }, {\n\t        key: 'isAnimating',\n\t        value: function isAnimating() {\n\t            return this.state.shouldAnimate || this.state.isClosing;\n\t        }\n\t\n\t        // Load image from src and call callback with image width and height on load\n\t\n\t    }, {\n\t        key: 'isImageLoaded',\n\t        value: function isImageLoaded(imageSrc) {\n\t            return imageSrc && imageSrc in this.imageCache && this.imageCache[imageSrc].loaded;\n\t        }\n\t\n\t        // Load image from src and call callback with image width and height on load\n\t\n\t    }, {\n\t        key: 'loadImage',\n\t        value: function loadImage(imageSrc, callback) {\n\t            var _this5 = this;\n\t\n\t            // Return the image info if it is already cached\n\t            if (this.isImageLoaded(imageSrc)) {\n\t                setTimeout(function () {\n\t                    callback(null, _this5.imageCache[imageSrc].width, _this5.imageCache[imageSrc].height);\n\t                }, 1);\n\t                return;\n\t            }\n\t\n\t            var that = this;\n\t            var inMemoryImage = new Image();\n\t\n\t            inMemoryImage.onerror = function onError() {\n\t                callback('image load error');\n\t            };\n\t\n\t            inMemoryImage.onload = function onLoad() {\n\t                that.imageCache[imageSrc] = {\n\t                    loaded: true,\n\t                    width: this.width,\n\t                    height: this.height\n\t                };\n\t\n\t                callback(null, this.width, this.height);\n\t            };\n\t\n\t            inMemoryImage.src = imageSrc;\n\t        }\n\t\n\t        // Load all images and their thumbnails\n\t\n\t    }, {\n\t        key: 'loadAllImages',\n\t        value: function loadAllImages() {\n\t            var _this6 = this;\n\t\n\t            var props = arguments.length <= 0 || arguments[0] === undefined ? this.props : arguments[0];\n\t\n\t            var generateImageLoadedCallback = function generateImageLoadedCallback(srcType, imageSrc) {\n\t                return function (err) {\n\t                    // Give up showing image on error\n\t                    if (err) {\n\t                        if (window.console) {\n\t                            window.console.warn(err);\n\t                        }\n\t                        return;\n\t                    }\n\t\n\t                    // Don't rerender if the src is not the same as when the load started\n\t                    if (_this6.props[srcType] !== imageSrc) {\n\t                        return;\n\t                    }\n\t\n\t                    // Force rerender with the new image\n\t                    _this6.forceUpdate();\n\t                };\n\t            };\n\t\n\t            // Load the images\n\t            this.getSrcTypes().forEach(function (srcType) {\n\t                var type = srcType.name;\n\t\n\t                // Load unloaded images\n\t                if (props[type] && !_this6.isImageLoaded(props[type])) {\n\t                    _this6.loadImage(props[type], generateImageLoadedCallback(type, props[type]));\n\t                }\n\t            });\n\t        }\n\t\n\t        // Request that the lightbox be closed\n\t\n\t    }, {\n\t        key: 'requestClose',\n\t        value: function requestClose(event) {\n\t            var _this7 = this;\n\t\n\t            // Call the parent close request\n\t            var closeLightbox = function closeLightbox() {\n\t                return _this7.props.onCloseRequest(event);\n\t            };\n\t\n\t            if (this.props.animationDisabled || event.type === 'keydown' && !this.props.animationOnKeyInput) {\n\t                // No animation\n\t                return closeLightbox();\n\t            }\n\t\n\t            // With animation\n\t            // Start closing animation\n\t            this.setState({ isClosing: true });\n\t\n\t            // Perform the actual closing at the end of the animation\n\t            setTimeout(closeLightbox, this.props.animationDuration);\n\t        }\n\t    }, {\n\t        key: 'requestMove',\n\t        value: function requestMove(direction, event) {\n\t            var _this8 = this;\n\t\n\t            // Reset the zoom level on image move\n\t            var nextState = {\n\t                zoomLevel: _constant.MIN_ZOOM_LEVEL,\n\t                offsetX: 0,\n\t                offsetY: 0\n\t            };\n\t\n\t            // Enable animated states\n\t            if (!this.props.animationDisabled && (!this.keyPressed || this.props.animationOnKeyInput)) {\n\t                nextState.shouldAnimate = true;\n\t                setTimeout(function () {\n\t                    return _this8.setState({ shouldAnimate: false });\n\t                }, this.props.animationDuration);\n\t            }\n\t            this.keyPressed = false;\n\t\n\t            this.moveRequested = true;\n\t\n\t            if (direction === 'prev') {\n\t                this.keyCounter--;\n\t                this.setState(nextState);\n\t                this.props.onMovePrevRequest(event);\n\t            } else {\n\t                this.keyCounter++;\n\t                this.setState(nextState);\n\t                this.props.onMoveNextRequest(event);\n\t            }\n\t        }\n\t\n\t        // Request to transition to the next image\n\t\n\t    }, {\n\t        key: 'requestMoveNext',\n\t        value: function requestMoveNext(event) {\n\t            this.requestMove('next', event);\n\t        }\n\t\n\t        // Request to transition to the previous image\n\t\n\t    }, {\n\t        key: 'requestMovePrev',\n\t        value: function requestMovePrev(event) {\n\t            this.requestMove('prev', event);\n\t        }\n\t    }, {\n\t        key: 'render',\n\t        value: function render() {\n\t            var _this9 = this;\n\t\n\t            var transitionStyle = {};\n\t\n\t            // Transition settings for sliding animations\n\t            if (!this.props.animationDisabled && this.isAnimating()) {\n\t                transitionStyle = _extends({}, transitionStyle, {\n\t                    transition: ['transform', 'left', 'top', 'right', 'bottom'].map(function (x) {\n\t                        return x + ' ' + _this9.props.animationDuration + 'ms';\n\t                    }).join(', ')\n\t                });\n\t            }\n\t\n\t            // Key endings to differentiate between images with the same src\n\t            var keyEndings = {};\n\t            this.getSrcTypes().forEach(function (_ref) {\n\t                var name = _ref.name;\n\t                var keyEnding = _ref.keyEnding;\n\t\n\t                keyEndings[name] = keyEnding;\n\t            });\n\t\n\t            // Images to be displayed\n\t            var images = [];\n\t            var addImage = function addImage(srcType, imageClass) {\n\t                var baseStyle = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t                // Ignore types that have no source defined for their full size image\n\t                if (!_this9.props[srcType]) {\n\t                    return;\n\t                }\n\t\n\t                var imageStyle = _extends({}, baseStyle, transitionStyle);\n\t                if (_this9.state.zoomLevel > _constant.MIN_ZOOM_LEVEL) {\n\t                    imageStyle.cursor = 'move';\n\t                }\n\t\n\t                var bestImageInfo = _this9.getBestImageForType(srcType);\n\t                if (bestImageInfo === null) {\n\t                    // Fall back to loading icon if the thumbnail has not been loaded\n\t                    images.push(_react2.default.createElement('div', {\n\t                        className: imageClass + ' ' + styles.image + ' not-loaded',\n\t                        style: imageStyle,\n\t                        key: _this9.props[srcType] + keyEndings[srcType]\n\t                    }));\n\t\n\t                    return;\n\t                }\n\t\n\t                imageStyle.width = bestImageInfo.width;\n\t                imageStyle.height = bestImageInfo.height;\n\t\n\t                var imageSrc = bestImageInfo.src;\n\t                if (_this9.props.discourageDownloads) {\n\t                    imageStyle.backgroundImage = 'url(\\'' + imageSrc + '\\')';\n\t                    images.push(_react2.default.createElement(\n\t                        'div',\n\t                        {\n\t                            className: imageClass + ' ' + styles.image + ' ' + styles.imageDiscourager,\n\t                            onDoubleClick: _this9.handleImageDoubleClick,\n\t                            onWheel: _this9.handleImageMouseWheel,\n\t                            style: imageStyle,\n\t                            key: imageSrc + keyEndings[srcType]\n\t                        },\n\t                        _react2.default.createElement('div', { className: 'download-blocker ${styles.downloadBlocker}' })\n\t                    ));\n\t                } else {\n\t                    images.push(_react2.default.createElement('img', {\n\t                        className: imageClass + ' ' + styles.image,\n\t                        onDoubleClick: _this9.handleImageDoubleClick,\n\t                        onWheel: _this9.handleImageMouseWheel,\n\t                        style: imageStyle,\n\t                        src: imageSrc,\n\t                        key: imageSrc + keyEndings[srcType],\n\t                        alt: _this9.props.imageTitle || (0, _util.translate)('Image')\n\t                    }));\n\t                }\n\t            };\n\t\n\t            var zoomMultiplier = this.getZoomMultiplier();\n\t            // Next Image (displayed on the right)\n\t            addImage('nextSrc', 'image-next ' + styles.imageNext);\n\t            // Main Image\n\t            addImage('mainSrc', 'image-current', {\n\t                transform: 'scale3d(' + zoomMultiplier + ', ' + zoomMultiplier + ', 1)',\n\t                left: -1 * zoomMultiplier * this.state.offsetX,\n\t                right: zoomMultiplier * this.state.offsetX,\n\t                top: -1 * zoomMultiplier * this.state.offsetY,\n\t                bottom: zoomMultiplier * this.state.offsetY\n\t            });\n\t            // Previous Image (displayed on the left)\n\t            addImage('prevSrc', 'image-prev ' + styles.imagePrev);\n\t\n\t            var noop = function noop() {};\n\t\n\t            // Prepare styles and handlers for the zoom in/out buttons\n\t            var zoomInButtonClasses = [styles.toolbarItemChild, styles.builtinButton, styles.zoomInButton];\n\t            var zoomOutButtonClasses = [styles.toolbarItemChild, styles.builtinButton, styles.zoomOutButton];\n\t            var zoomInButtonHandler = this.handleZoomInButtonClick;\n\t            var zoomOutButtonHandler = this.handleZoomOutButtonClick;\n\t\n\t            // Disable zooming in when zoomed all the way in\n\t            if (this.state.zoomLevel === _constant.MAX_ZOOM_LEVEL) {\n\t                zoomInButtonClasses.push(styles.builtinButtonDisabled);\n\t                zoomInButtonHandler = noop;\n\t            }\n\t\n\t            // Disable zooming out when zoomed all the way out\n\t            if (this.state.zoomLevel === _constant.MIN_ZOOM_LEVEL) {\n\t                zoomOutButtonClasses.push(styles.builtinButtonDisabled);\n\t                zoomOutButtonHandler = noop;\n\t            }\n\t\n\t            // Ignore clicks during animation\n\t            if (this.isAnimating()) {\n\t                zoomInButtonHandler = noop;\n\t                zoomOutButtonHandler = noop;\n\t            }\n\t\n\t            // Clear default modal appearance\n\t            var modalStyle = {\n\t                overlay: {\n\t                    zIndex: 1000,\n\t                    backgroundColor: 'transparent'\n\t                },\n\t                content: {\n\t                    backgroundColor: 'transparent',\n\t                    border: 'none',\n\t                    borderRadius: 0,\n\t                    top: 0,\n\t                    left: 0,\n\t                    right: 0,\n\t                    bottom: 0\n\t                }\n\t            };\n\t\n\t            return _react2.default.createElement(\n\t                'div',\n\t                null,\n\t                _react2.default.createElement(\n\t                    'div',\n\t                    { // Floating modal with closing animations\n\t                        onWheel: this.handleOuterMousewheel,\n\t                        onMouseMove: this.handleOuterMouseMove,\n\t                        onMouseDown: this.handleOuterMouseDown,\n\t                        onTouchStart: this.handleOuterTouchStart,\n\t                        onTouchMove: this.handleOuterTouchMove,\n\t                        className: 'outer ' + styles.outer + ' ' + styles.outerAnimating + (this.state.isClosing ? ' closing ' + styles.outerClosing : ''),\n\t                        style: {\n\t                            transition: 'opacity ' + this.props.animationDuration + 'ms',\n\t                            animationDuration: this.props.animationDuration + 'ms',\n\t                            animationDirection: this.state.isClosing ? 'normal' : 'reverse'\n\t                        }\n\t                    },\n\t                    _react2.default.createElement(\n\t                        'div',\n\t                        { // Image holder\n\t                            className: 'inner ' + styles.inner,\n\t                            onClick: this.props.clickOutsideToClose ? this.closeIfClickInner : noop\n\t                        },\n\t                        images\n\t                    ),\n\t                    !this.props.prevSrc ? '' : _react2.default.createElement('button', { // Move to previous image button\n\t                        type: 'button',\n\t                        className: 'prev-button ' + styles.navButtons + ' ' + styles.navButtonPrev,\n\t                        key: 'prev',\n\t                        onClick: !this.isAnimating() ? this.requestMovePrev : noop // Ignore clicks during animation\n\t                    }),\n\t                    !this.props.nextSrc ? '' : _react2.default.createElement('button', { // Move to next image button\n\t                        type: 'button',\n\t                        className: 'next-button ' + styles.navButtons + ' ' + styles.navButtonNext,\n\t                        key: 'next',\n\t                        onClick: !this.isAnimating() ? this.requestMoveNext : noop // Ignore clicks during animation\n\t                    }),\n\t                    _react2.default.createElement(\n\t                        'div',\n\t                        { // Lightbox toolbar\n\t                            className: 'toolbar ' + styles.toolbar\n\t                        },\n\t                        _react2.default.createElement(\n\t                            'ul',\n\t                            { className: 'toolbar-left ' + styles.toolbarSide + ' ' + styles.toolbarLeftSide },\n\t                            _react2.default.createElement(\n\t                                'li',\n\t                                { className: styles.toolbarItem },\n\t                                _react2.default.createElement(\n\t                                    'span',\n\t                                    { className: styles.toolbarItemChild },\n\t                                    this.props.imageTitle\n\t                                )\n\t                            )\n\t                        ),\n\t                        _react2.default.createElement(\n\t                            'ul',\n\t                            { className: 'toolbar-right ' + styles.toolbarSide + ' ' + styles.toolbarRightSide },\n\t                            !this.props.toolbarButtons ? '' : this.props.toolbarButtons.map(function (button, i) {\n\t                                return _react2.default.createElement(\n\t                                    'li',\n\t                                    { key: i, className: styles.toolbarItem },\n\t                                    button\n\t                                );\n\t                            }),\n\t                            _react2.default.createElement(\n\t                                'li',\n\t                                { className: styles.toolbarItem },\n\t                                _react2.default.createElement('button', { // Lightbox zoom in button\n\t                                    type: 'button',\n\t                                    key: 'zoom-in',\n\t                                    className: 'zoom-in ' + zoomInButtonClasses.join(' '),\n\t                                    onClick: zoomInButtonHandler\n\t                                })\n\t                            ),\n\t                            _react2.default.createElement(\n\t                                'li',\n\t                                { className: styles.toolbarItem },\n\t                                _react2.default.createElement('button', { // Lightbox zoom out button\n\t                                    type: 'button',\n\t                                    key: 'zoom-out',\n\t                                    className: 'zoom-out ' + zoomOutButtonClasses.join(' '),\n\t                                    onClick: zoomOutButtonHandler\n\t                                })\n\t                            ),\n\t                            _react2.default.createElement(\n\t                                'li',\n\t                                { className: styles.toolbarItem },\n\t                                _react2.default.createElement('button', { // Lightbox close button\n\t                                    type: 'button',\n\t                                    key: 'close',\n\t                                    className: 'close ' + styles.toolbarItemChild + (' ' + styles.builtinButton + ' ' + styles.closeButton),\n\t                                    onClick: !this.isAnimating() ? this.requestClose : noop // Ignore clicks during animation\n\t                                })\n\t                            )\n\t                        )\n\t                    )\n\t                )\n\t            );\n\t        }\n\t    }]);\n\t\n\t    return ReactImageLightbox;\n\t}(_react.Component);\n\t\n\tReactImageLightbox.propTypes = {\n\t    //-----------------------------\n\t    // Image sources\n\t    //-----------------------------\n\t\n\t    // Main display image url\n\t    mainSrc: _react.PropTypes.string.isRequired,\n\t\n\t    // Previous display image url (displayed to the left)\n\t    // If left undefined, movePrev actions will not be performed, and the button not displayed\n\t    prevSrc: _react.PropTypes.string,\n\t\n\t    // Next display image url (displayed to the right)\n\t    // If left undefined, moveNext actions will not be performed, and the button not displayed\n\t    nextSrc: _react.PropTypes.string,\n\t\n\t    //-----------------------------\n\t    // Image thumbnail sources\n\t    //-----------------------------\n\t\n\t    // Thumbnail image url corresponding to props.mainSrc\n\t    mainSrcThumbnail: _react.PropTypes.string,\n\t\n\t    // Thumbnail image url corresponding to props.prevSrc\n\t    prevSrcThumbnail: _react.PropTypes.string,\n\t\n\t    // Thumbnail image url corresponding to props.nextSrc\n\t    nextSrcThumbnail: _react.PropTypes.string,\n\t\n\t    //-----------------------------\n\t    // Event Handlers\n\t    //-----------------------------\n\t\n\t    // Close window event\n\t    // Should change the parent state such that the lightbox is not rendered\n\t    onCloseRequest: _react.PropTypes.func.isRequired,\n\t\n\t    // Move to previous image event\n\t    // Should change the parent state such that props.prevSrc becomes props.mainSrc,\n\t    //  props.mainSrc becomes props.nextSrc, etc.\n\t    onMovePrevRequest: _react.PropTypes.func,\n\t\n\t    // Move to next image event\n\t    // Should change the parent state such that props.nextSrc becomes props.mainSrc,\n\t    //  props.mainSrc becomes props.prevSrc, etc.\n\t    onMoveNextRequest: _react.PropTypes.func,\n\t\n\t    //-----------------------------\n\t    // Download discouragement settings\n\t    //-----------------------------\n\t\n\t    // Enable download discouragement (prevents [right-click -> Save Image As...])\n\t    discourageDownloads: _react.PropTypes.bool,\n\t\n\t    //-----------------------------\n\t    // Animation settings\n\t    //-----------------------------\n\t\n\t    // Disable all animation\n\t    animationDisabled: _react.PropTypes.bool,\n\t\n\t    // Disable animation on actions performed with keyboard shortcuts\n\t    animationOnKeyInput: _react.PropTypes.bool,\n\t\n\t    // Animation duration (ms)\n\t    animationDuration: _react.PropTypes.number,\n\t\n\t    //-----------------------------\n\t    // Keyboard shortcut settings\n\t    //-----------------------------\n\t\n\t    // Required interval of time (ms) between key actions\n\t    // (prevents excessively fast navigation of images)\n\t    keyRepeatLimit: _react.PropTypes.number,\n\t\n\t    // Amount of time (ms) restored after each keyup\n\t    // (makes rapid key presses slightly faster than holding down the key to navigate images)\n\t    keyRepeatKeyupBonus: _react.PropTypes.number,\n\t\n\t    //-----------------------------\n\t    // Image info\n\t    //-----------------------------\n\t\n\t    // Image title\n\t    imageTitle: _react.PropTypes.node,\n\t\n\t    //-----------------------------\n\t    // Other\n\t    //-----------------------------\n\t\n\t    // Array of custom toolbar buttons\n\t    toolbarButtons: _react.PropTypes.arrayOf(_react.PropTypes.node),\n\t\n\t    // Padding (px) between the edge of the window and the lightbox\n\t    imagePadding: _react.PropTypes.number,\n\t\n\t    // When true, clicks outside of the image close the lightbox\n\t    clickOutsideToClose: _react.PropTypes.bool\n\t};\n\t\n\tReactImageLightbox.defaultProps = {\n\t    onMovePrevRequest: function onMovePrevRequest() {},\n\t    onMoveNextRequest: function onMoveNextRequest() {},\n\t\n\t    discourageDownloads: false,\n\t\n\t    animationDisabled: false,\n\t    animationOnKeyInput: false,\n\t    animationDuration: 300,\n\t\n\t    keyRepeatLimit: 180,\n\t    keyRepeatKeyupBonus: 40,\n\t\n\t    imagePadding: 10,\n\t    clickOutsideToClose: true\n\t};\n\t\n\texports.default = ReactImageLightbox;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.getIEVersion = getIEVersion;\n\texports.translate = translate;\n\texports.getWindowWidth = getWindowWidth;\n\texports.getWindowHeight = getWindowHeight;\n\texports.isInIframe = isInIframe;\n\t/**\n\t * Get the version of Internet Explorer in use, or undefined\n\t *\n\t * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\n\t */\n\tfunction getIEVersion() {\n\t    var match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\n\t    return match ? parseInt(match[1], 10) : undefined;\n\t}\n\t\n\t/**\n\t * Placeholder for future translate functionality\n\t */\n\tfunction translate(str) {\n\t    var replaceStrings = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\t\n\t    if (!str) {\n\t        return '';\n\t    }\n\t\n\t    var translated = str;\n\t    if (replaceStrings) {\n\t        Object.keys(replaceStrings).forEach(function (placeholder) {\n\t            translated = translated.replace(placeholder, replaceStrings[placeholder]);\n\t        });\n\t    }\n\t\n\t    return translated;\n\t}\n\t\n\tfunction getWindowWidth() {\n\t    return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t}\n\t\n\tfunction getWindowHeight() {\n\t    return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t}\n\t\n\t// Returns true if this window is rendered as an iframe inside another window\n\tfunction isInIframe() {\n\t    try {\n\t        return window.self !== window.top;\n\t    } catch (e) {\n\t        return true;\n\t    }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** react-image-lightbox.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 28d70775e6f449cdc3e0\n **/","module.exports = require('./react-image-lightbox').default;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","// Min image zoom level\nexport const MIN_ZOOM_LEVEL = 0;\n\n// Max image zoom level\nexport const MAX_ZOOM_LEVEL = 300;\n\n// Size ratio between previous and next zoom levels\nexport const ZOOM_RATIO = 1.007;\n\n// How much to increase/decrease the zoom level when the zoom buttons are clicked\nexport const ZOOM_BUTTON_INCREMENT_SIZE = 100;\n\n// Used to judge the amount of horizontal scroll needed to initiate a image move\nexport const WHEEL_MOVE_X_THRESHOLD = 200;\n\n// Used to judge the amount of vertical scroll needed to initiate a zoom action\nexport const WHEEL_MOVE_Y_THRESHOLD = 1;\n\nexport const KEYS = {\n    ESC:         27,\n    LEFT_ARROW:  37,\n    RIGHT_ARROW: 39,\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constant.js\n **/","/*\n * react-image-lightbox\n * Copyright 2016 Chris Fritz All rights reserved.\n * @license Open source under the MIT License\n */\n\nimport React, { Component, PropTypes } from 'react';\n//import Modal from 'react-modal';\nimport {\n    translate,\n    getWindowWidth,\n    getWindowHeight,\n    isInIframe,\n    getIEVersion,\n} from './util';\nimport {\n    KEYS,\n    MIN_ZOOM_LEVEL,\n    MAX_ZOOM_LEVEL,\n    ZOOM_RATIO,\n    WHEEL_MOVE_X_THRESHOLD,\n    WHEEL_MOVE_Y_THRESHOLD,\n    ZOOM_BUTTON_INCREMENT_SIZE,\n} from './constant';\n\n\n\nrequire('./style.scss')\n\n// Add fallback classes for browsers without flexbox support\nlet styles = {\"builtinButtonDisabled\":\"builtinButtonDisabled_rilu\",\n\"builtinButton\":\"builtinButton_rilu\",\n\"closeButton\":\"closeButton_rilu\",\n\"closeWindow\":\"closeWindow_rilu\",\n\"closeWindow\":\"closeWindow_rilu\",\n\"downloadBlocker\":\"downloadBlocker_rilu\",\n\"imageDiscourager\":\"imageDiscourager_rilu\",\n\"imageNext\":\"imageNext_rilu\",\n\"imagePrev\":\"imagePrev_rilu\",\n\"image\":\"image_rilu\",\n\"inner\":\"inner_rilu\",\n\"navButtonNext\":\"navButtonNext_rilu\",\n\"navButtonPrev\":\"navButtonPrev_rilu\",\n\"navButtons\":\"navButtons_rilu\",\n\"outerAnimating\":\"outerAnimating_rilu\",\n\"outerClosing\":\"outerClosing_rilu\",\n\"outer\":\"outer_rilu\",\n\"toolbarItemChild\":\"toolbarItemChild_rilu\",\n\"toolbarItem\":\"toolbarItem_rilu\",\n\"toolbarLeftSideNoFlex\":\"toolbarLeftSideNoFlex_rilu\",\n\"toolbarLeftSide\":\"toolbarLeftSide_rilu\",\n\"toolbarRightSideNoFlex\":\"toolbarRightSideNoFlex_rilu\",\n\"toolbarRightSide\":\"toolbarRightSide_rilu\",\n\"toolbarSideNoFlex\":\"toolbarSideNoFlex_rilu\",\n\"toolbarSide\":\"toolbarSide_rilu\",\n\"toolbar\":\"toolbar_rilu\",\n\"zoomInButton\":\"zoomInButton_rilu\",\n\"zoomOutButton\":\"zoomOutButton_rilu\"}\n/**if (getIEVersion() < 10) {\n    styles = {\n        ...styles,\n        toolbarSide:      `${styles.toolbarSide} ${styles.toolbarSideNoFlex}`,\n        toolbarLeftSide:  `${styles.toolbarLeftSide} ${styles.toolbarLeftSideNoFlex}`,\n        toolbarRightSide: `${styles.toolbarRightSide} ${styles.toolbarRightSideNoFlex}`,\n    };\n}**/\n\nclass ReactImageLightbox extends Component {\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            //-----------------------------\n            // Animation\n            //-----------------------------\n\n            // Lightbox is closing\n            // When Lightbox is mounted, if animation is enabled it will open with the reverse of the closing animation\n            isClosing: !props.animationDisabled,\n\n            // Component parts should animate (e.g., when images are moving, or image is being zoomed)\n            shouldAnimate: false,\n\n            //-----------------------------\n            // Zoom settings\n            //-----------------------------\n            // Zoom level of image\n            zoomLevel: MIN_ZOOM_LEVEL,\n\n            //-----------------------------\n            // Image position settings\n            //-----------------------------\n            // Horizontal offset from center\n            offsetX: 0,\n\n            // Vertical offset from center\n            offsetY: 0,\n        };\n\n        this.closeIfClickInner        = this.closeIfClickInner.bind(this);\n        this.handleImageDoubleClick   = this.handleImageDoubleClick.bind(this);\n        this.handleImageMouseWheel    = this.handleImageMouseWheel.bind(this);\n        this.handleKeyInput           = this.handleKeyInput.bind(this);\n        this.handleMouseUp            = this.handleMouseUp.bind(this);\n        this.handleOuterMouseDown     = this.handleOuterMouseDown.bind(this);\n        this.handleOuterMouseMove     = this.handleOuterMouseMove.bind(this);\n        this.handleOuterMousewheel    = this.handleOuterMousewheel.bind(this);\n        this.handleOuterTouchStart    = this.handleOuterTouchStart.bind(this);\n        this.handleOuterTouchMove     = this.handleOuterTouchMove.bind(this);\n        this.handleWindowResize       = this.handleWindowResize.bind(this);\n        this.handleZoomInButtonClick  = this.handleZoomInButtonClick.bind(this);\n        this.handleZoomOutButtonClick = this.handleZoomOutButtonClick.bind(this);\n        this.requestClose             = this.requestClose.bind(this);\n        this.requestMoveNext          = this.requestMoveNext.bind(this);\n        this.requestMovePrev          = this.requestMovePrev.bind(this);\n    }\n\n    componentWillMount() {\n        // Whether event listeners for keyboard and mouse input have been attached or not\n        this.listenersAttached = false;\n\n        // Used to disable animation when changing props.mainSrc|nextSrc|prevSrc\n        this.keyPressed = false;\n\n        // Used to store load state / dimensions of images\n        this.imageCache = {};\n\n        // Time the last keydown event was called (used in keyboard action rate limiting)\n        this.lastKeyDownTime = 0;\n\n        // Used for debouncing window resize event\n        this.resizeTimeout = null;\n\n        // Used to determine when actions are triggered by the scroll wheel\n        this.wheelActionTimeout = null;\n        this.resetScrollTimeout = null;\n        this.scrollX            = 0;\n        this.scrollY            = 0;\n\n        // Used in panning zoomed images\n        this.isDragging       = false;\n        this.dragStartX       = 0;\n        this.dragStartY       = 0;\n        this.dragStartOffsetX = 0;\n        this.dragStartOffsetY = 0;\n\n        // Used to differentiate between images with identical src\n        this.keyCounter = 0;\n\n        // Used to detect a move when all src's remain unchanged (four or more of the same image in a row)\n        this.moveRequested = false;\n\n        if (!this.props.animationDisabled) {\n            // Make opening animation play\n            this.setState({ isClosing: false });\n        }\n    }\n\n    componentDidMount() {\n        this.attachListeners();\n\n        this.loadAllImages();\n    }\n\n    componentWillReceiveProps(nextProps) {\n        const sourcesChanged = this.getSrcTypes().some(srcType =>\n            this.props[srcType.name] !== nextProps[srcType.name]\n        );\n\n        if (sourcesChanged || this.moveRequested) {\n            this.moveRequested = false;\n\n            // Load any new images\n            this.loadAllImages(nextProps);\n        }\n    }\n\n    componentWillUnmount() {\n        this.detachListeners();\n    }\n\n    // Attach key and mouse input events\n    attachListeners() {\n        if (!this.listenersAttached) {\n            document.addEventListener('keydown', this.handleKeyInput);\n            document.addEventListener('keyup', this.handleKeyInput);\n            window.addEventListener('resize', this.handleWindowResize);\n            window.addEventListener('mouseup', this.handleMouseUp);\n            window.addEventListener('touchend', this.handleMouseUp);\n\n            // Have to add an extra mouseup handler to catch mouseup events outside of the window\n            //  if the page containing the lightbox is displayed in an iframe\n            if (isInIframe()) {\n                window.top.addEventListener('mouseup', this.handleMouseUp);\n                window.top.addEventListener('touchend', this.handleMouseUp);\n            }\n\n            this.listenersAttached = true;\n        }\n    }\n\n    // Change zoom level\n    changeZoom(zoomLevel, clientX, clientY) {\n        const windowWidth  = getWindowWidth();\n        const windowHeight = getWindowHeight();\n\n        // Constrain zoom level to the set bounds\n        const nextZoomLevel = Math.max(MIN_ZOOM_LEVEL, Math.min(MAX_ZOOM_LEVEL, zoomLevel));\n\n        // Ignore requests that don't change the zoom level\n        if (nextZoomLevel === this.state.zoomLevel) {\n            return;\n        } else if (nextZoomLevel === MIN_ZOOM_LEVEL) {\n            // Snap back to center if zoomed all the way out\n            return this.setState({\n                zoomLevel: nextZoomLevel,\n                offsetX:   0,\n                offsetY:   0,\n            });\n        }\n\n        const currentZoomMultiplier = this.getZoomMultiplier();\n        const nextZoomMultiplier    = this.getZoomMultiplier(nextZoomLevel);\n\n        // Default to the center of the screen to zoom when no mouse position specified\n        const percentXInCurrentBox = (typeof clientX !== 'undefined' ? clientX : windowWidth / 2) / windowWidth;\n        const percentYInCurrentBox = (typeof clientY !== 'undefined' ? clientY : windowHeight / 2) / windowHeight;\n\n        const currentBoxWidth  = windowWidth / currentZoomMultiplier;\n        const currentBoxHeight = windowHeight / currentZoomMultiplier;\n\n        const nextBoxWidth  = windowWidth / nextZoomMultiplier;\n        const nextBoxHeight = windowHeight / nextZoomMultiplier;\n\n        const deltaX = (nextBoxWidth - currentBoxWidth) * (percentXInCurrentBox - 0.5);\n        const deltaY = (nextBoxHeight - currentBoxHeight) * (percentYInCurrentBox - 0.5);\n\n        let nextOffsetX = this.state.offsetX - deltaX;\n        let nextOffsetY = this.state.offsetY - deltaY;\n\n        // When zooming out, limit the offset so things don't get left askew\n        const maxOffsets = this.getMaxOffsets();\n        if (this.state.zoomLevel > nextZoomLevel) {\n            nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, nextOffsetX));\n            nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, nextOffsetY));\n        }\n\n        this.setState({\n            zoomLevel: nextZoomLevel,\n            offsetX:   nextOffsetX,\n            offsetY:   nextOffsetY,\n        });\n    }\n\n    closeIfClickInner(event) {\n        if (event.target.className.search(/\\binner\\b/) > -1) {\n            this.requestClose(event);\n        }\n    }\n\n    // Detach key and mouse input events\n    detachListeners() {\n        if (this.listenersAttached) {\n            document.removeEventListener('keydown', this.handleKeyInput);\n            document.removeEventListener('keyup', this.handleKeyInput);\n            window.removeEventListener('resize', this.handleWindowResize);\n            window.removeEventListener('mouseup', this.handleMouseUp);\n            window.removeEventListener('touchend', this.handleMouseUp);\n\n            if (isInIframe()) {\n                window.top.removeEventListener('mouseup', this.handleMouseUp);\n                window.top.removeEventListener('touchend', this.handleMouseUp);\n            }\n\n            this.listenersAttached = false;\n        }\n    }\n\n    // Get info for the best suited image to display with the given srcType\n    getBestImageForType(srcType) {\n        let imageSrc = this.props[srcType];\n        let fitSizes = {};\n\n        if (this.isImageLoaded(imageSrc)) {\n            // Use full-size image if available\n            fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height);\n        } else if (this.isImageLoaded(this.props[`${srcType}Thumbnail`])) {\n            // Fall back to using thumbnail if the image has not been loaded\n            imageSrc = this.props[`${srcType}Thumbnail`];\n            fitSizes = this.getFitSizes(this.imageCache[imageSrc].width, this.imageCache[imageSrc].height, true);\n        } else {\n            return null;\n        }\n\n        return {\n            src:    imageSrc,\n            height: fitSizes.height,\n            width:  fitSizes.width,\n        };\n    }\n\n    // Get sizing for when an image is larger than the window\n    getFitSizes(width, height, stretch) {\n        const windowHeight = getWindowHeight();\n        const windowWidth  = getWindowWidth();\n        let maxHeight      = windowHeight - (this.props.imagePadding * 2);\n        let maxWidth       = windowWidth - (this.props.imagePadding * 2);\n\n        if (!stretch) {\n            maxHeight = Math.min(maxHeight, height);\n            maxWidth  = Math.min(maxWidth, width);\n        }\n\n        const maxRatio = maxWidth / maxHeight;\n        const srcRatio = width / height;\n\n        const fitSizes = {};\n        if (maxRatio > srcRatio) { // height is the constraining dimension of the photo\n            fitSizes.width  = width * maxHeight / height;\n            fitSizes.height = maxHeight;\n        } else {\n            fitSizes.width  = maxWidth;\n            fitSizes.height = height * maxWidth / width;\n        }\n\n        return fitSizes;\n    }\n\n    getMaxOffsets(zoomLevel = this.state.zoomLevel) {\n        const currentImageInfo = this.getBestImageForType('mainSrc');\n        if (currentImageInfo === null) {\n            return { maxX: 0, minX: 0, maxY: 0, minY: 0 };\n        }\n\n        const windowWidth    = getWindowWidth();\n        const windowHeight   = getWindowHeight();\n        const zoomMultiplier = this.getZoomMultiplier(zoomLevel);\n\n        let maxX = 0;\n        if (currentImageInfo.width - (windowWidth / zoomMultiplier) < 0) {\n            // if there is still blank space in the X dimension, don't limit except to the opposite edge\n            maxX = ((windowWidth / zoomMultiplier) - currentImageInfo.width) / 2;\n        } else {\n            maxX = (currentImageInfo.width - (windowWidth / zoomMultiplier)) / 2;\n        }\n\n        let maxY = 0;\n        if (currentImageInfo.height - (windowHeight / zoomMultiplier) < 0) {\n            // if there is still blank space in the Y dimension, don't limit except to the opposite edge\n            maxY = ((windowHeight / zoomMultiplier) - currentImageInfo.height) / 2;\n        } else {\n            maxY = (currentImageInfo.height - (windowHeight / zoomMultiplier)) / 2;\n        }\n\n        return {\n            maxX,\n            maxY,\n            minX: -1 * maxX,\n            minY: -1 * maxY,\n        };\n    }\n\n    getOffsetXFromWindowCenter(x) {\n        const windowWidth  = getWindowWidth();\n        return windowWidth / 2 - x;\n    }\n\n    getOffsetYFromWindowCenter(y) {\n        const windowHeight = getWindowHeight();\n        return windowHeight / 2 - y;\n    }\n\n    // Get image src types\n    getSrcTypes() {\n        return [\n            {\n                name:      'mainSrc',\n                keyEnding: `i${this.keyCounter}`,\n            },\n            {\n                name:      'mainSrcThumbnail',\n                keyEnding: `t${this.keyCounter}`,\n            },\n            {\n                name:      'nextSrc',\n                keyEnding: `i${this.keyCounter + 1}`,\n            },\n            {\n                name:      'nextSrcThumbnail',\n                keyEnding: `t${this.keyCounter + 1}`,\n            },\n            {\n                name:      'prevSrc',\n                keyEnding: `i${this.keyCounter - 1}`,\n            },\n            {\n                name:      'prevSrcThumbnail',\n                keyEnding: `t${this.keyCounter - 1}`,\n            },\n        ];\n    }\n\n    // Get sizing when the image is scaled\n    getZoomMultiplier(zoomLevel = this.state.zoomLevel) {\n        return Math.pow(ZOOM_RATIO, zoomLevel);\n    }\n\n    // Handle user keyboard actions\n    handleKeyInput(event) {\n        event.stopPropagation();\n\n        // Ignore key input during animations\n        if (this.isAnimating()) {\n            return;\n        }\n\n        // Allow slightly faster navigation through the images when user presses keys repeatedly\n        if (event.type === 'keyup') {\n            this.lastKeyDownTime -= this.props.keyRepeatKeyupBonus;\n            return;\n        }\n\n        const keyCode = event.which || event.keyCode;\n\n        // Ignore key presses that happen too close to each other (when rapid fire key pressing or holding down the key)\n        // But allow it if it's a lightbox closing action\n        const currentTime = new Date();\n        if ((currentTime.getTime() - this.lastKeyDownTime) < this.props.keyRepeatLimit &&\n            keyCode !== KEYS.ESC\n        ) {\n            return;\n        }\n        this.lastKeyDownTime = currentTime.getTime();\n\n        switch (keyCode) {\n        // ESC key closes the lightbox\n        case KEYS.ESC:\n            event.preventDefault();\n            this.requestClose(event);\n            break;\n\n        // Left arrow key moves to previous image\n        case KEYS.LEFT_ARROW:\n            if (!this.props.prevSrc) {\n                return;\n            }\n\n            event.preventDefault();\n            this.keyPressed = true;\n            this.requestMovePrev(event);\n            break;\n\n        // Right arrow key moves to next image\n        case KEYS.RIGHT_ARROW:\n            if (!this.props.nextSrc) {\n                return;\n            }\n\n            event.preventDefault();\n            this.keyPressed = true;\n            this.requestMoveNext(event);\n            break;\n\n        default:\n        }\n    }\n\n    // Handle a mouse wheel event over the lightbox container\n    handleOuterMousewheel(event) {\n        // Prevent scrolling of the background\n        event.preventDefault();\n        event.stopPropagation();\n\n        const xThreshold = WHEEL_MOVE_X_THRESHOLD;\n        let actionDelay = 0;\n        const imageMoveDelay = 500;\n\n        clearTimeout(this.resetScrollTimeout);\n        this.resetScrollTimeout = setTimeout(() => {\n            this.scrollX = 0;\n            this.scrollY = 0;\n        }, 300);\n\n        // Prevent rapid-fire zoom behavior\n        if (this.wheelActionTimeout !== null || this.isAnimating()) {\n            return;\n        }\n\n        if (Math.abs(event.deltaY) < Math.abs(event.deltaX)) {\n            // handle horizontal scrolls with image moves\n            this.scrollY = 0;\n            this.scrollX += event.deltaX;\n\n            const bigLeapX = xThreshold / 2;\n            // If the scroll amount has accumulated sufficiently, or a large leap was taken\n            if (this.scrollX >= xThreshold || event.deltaX >= bigLeapX) {\n                // Scroll right moves to next\n                this.requestMoveNext(event);\n                actionDelay = imageMoveDelay;\n                this.scrollX = 0;\n            } else if (this.scrollX <= -1 * xThreshold || event.deltaX <= -1 * bigLeapX) {\n                // Scroll left moves to previous\n                this.requestMovePrev(event);\n                actionDelay = imageMoveDelay;\n                this.scrollX = 0;\n            }\n        }\n\n        // Allow successive actions after the set delay\n        if (actionDelay !== 0) {\n            this.wheelActionTimeout = setTimeout(() => {\n                this.wheelActionTimeout = null;\n            }, actionDelay);\n        }\n    }\n\n    handleImageMouseWheel(event) {\n        event.preventDefault();\n        const yThreshold = WHEEL_MOVE_Y_THRESHOLD;\n\n        if (Math.abs(event.deltaY) >= Math.abs(event.deltaX)) {\n            event.stopPropagation();\n            // If the vertical scroll amount was large enough, perform a zoom\n            if (Math.abs(event.deltaY) < yThreshold) {\n                return;\n            }\n\n            this.scrollX = 0;\n            this.scrollY += event.deltaY;\n\n            this.changeZoom(\n                this.state.zoomLevel - event.deltaY,\n                event.clientX,\n                event.clientY\n            );\n        }\n    }\n\n    // Handle a double click on the current image\n    handleImageDoubleClick(event) {\n        if (this.state.zoomLevel > MIN_ZOOM_LEVEL) {\n            // A double click when zoomed in zooms all the way out\n            this.changeZoom(\n                MIN_ZOOM_LEVEL,\n                event.clientX,\n                event.clientY\n            );\n        } else {\n            // A double click when zoomed all the way out zooms in\n            this.changeZoom(\n                this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE,\n                event.clientX,\n                event.clientY\n            );\n        }\n    }\n\n    // Handle a mouse click ending in the lightbox container\n    handleMouseUp() {\n        if (!this.isDragging) {\n            return;\n        }\n\n        this.isDragging = false;\n\n        // Snap image back into frame if outside max offset range\n        const maxOffsets = this.getMaxOffsets();\n        const nextOffsetX = Math.max(maxOffsets.minX, Math.min(maxOffsets.maxX, this.state.offsetX));\n        const nextOffsetY = Math.max(maxOffsets.minY, Math.min(maxOffsets.maxY, this.state.offsetY));\n        if (nextOffsetX !== this.state.offsetX || nextOffsetY !== this.state.offsetY) {\n            this.setState({\n                offsetX:       nextOffsetX,\n                offsetY:       nextOffsetY,\n                shouldAnimate: true,\n            });\n\n            setTimeout(() => {\n                this.setState({ shouldAnimate: false });\n            }, this.props.animationDuration);\n        }\n    }\n\n    // Handle move start over the lightbox container\n    // This happens:\n    // - On a mouseDown event\n    // - On a touchstart event\n    handleMoveStart(clientX, clientY) {\n        // Only allow dragging when zoomed\n        if (this.state.zoomLevel <= MIN_ZOOM_LEVEL) {\n            return;\n        }\n\n        this.isDragging       = true;\n        this.dragStartX       = clientX;\n        this.dragStartY       = clientY;\n        this.dragStartOffsetX = this.state.offsetX;\n        this.dragStartOffsetY = this.state.offsetY;\n    }\n\n    // Handle the mouse clicking down in the lightbox container\n    handleOuterMouseDown(event) {\n        event.preventDefault();\n        this.handleMoveStart(event.clientX, event.clientY);\n    }\n\n    // Touch screen version of handleOuterMouseDown()\n    handleOuterTouchStart(event) {\n        const touchObj = event.changedTouches[0];\n        this.handleMoveStart(parseInt(touchObj.clientX, 10), parseInt(touchObj.clientY, 10));\n    }\n\n    // Handle dragging over the lightbox container\n    // This happens:\n    // - After a mouseDown and before a mouseUp event\n    // - After a touchstart and before a touchend event\n    handleMove(clientX, clientY) {\n        if (!this.isDragging) {\n            return;\n        }\n\n        const zoomMultiplier = this.getZoomMultiplier();\n\n        const newOffsetX = (this.dragStartX - clientX) / zoomMultiplier + this.dragStartOffsetX;\n        const newOffsetY = (this.dragStartY - clientY) / zoomMultiplier + this.dragStartOffsetY;\n        if (this.state.offsetX !== newOffsetX || this.state.offsetY !== newOffsetY) {\n            this.setState({\n                offsetX: newOffsetX,\n                offsetY: newOffsetY,\n            });\n        }\n    }\n\n    // Handle the mouse dragging over the lightbox container\n    // (after a mouseDown and before a mouseUp event)\n    handleOuterMouseMove(event) {\n        this.handleMove(event.clientX, event.clientY);\n    }\n\n    // Touch screen version of handleOuterMouseMove()\n    handleOuterTouchMove(event) {\n        event.preventDefault();\n\n        // We shouldn't go any further if we're not zoomed\n        if (this.state.zoomLevel <= MIN_ZOOM_LEVEL) {\n            return;\n        }\n\n        const touchObj = event.changedTouches[0];\n        this.handleMove(parseInt(touchObj.clientX, 10), parseInt(touchObj.clientY, 10));\n    }\n\n    // Handle the window resize event\n    handleWindowResize() {\n        clearTimeout(this.resizeTimeout);\n        this.resizeTimeout = setTimeout(this.forceUpdate.bind(this), 100);\n    }\n\n    handleZoomInButtonClick() {\n        this.changeZoom(this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE);\n    }\n\n    handleZoomOutButtonClick() {\n        this.changeZoom(this.state.zoomLevel - ZOOM_BUTTON_INCREMENT_SIZE);\n    }\n\n    // Detach key and mouse input events\n    isAnimating() {\n        return this.state.shouldAnimate || this.state.isClosing;\n    }\n\n    // Load image from src and call callback with image width and height on load\n    isImageLoaded(imageSrc) {\n        return imageSrc && (imageSrc in this.imageCache) && this.imageCache[imageSrc].loaded;\n    }\n\n    // Load image from src and call callback with image width and height on load\n    loadImage(imageSrc, callback) {\n        // Return the image info if it is already cached\n        if (this.isImageLoaded(imageSrc)) {\n            setTimeout(() => {\n                callback(null, this.imageCache[imageSrc].width, this.imageCache[imageSrc].height);\n            }, 1);\n            return;\n        }\n\n        const that = this;\n        const inMemoryImage = new Image();\n\n        inMemoryImage.onerror = function onError() {\n            callback('image load error');\n        };\n\n        inMemoryImage.onload = function onLoad() {\n            that.imageCache[imageSrc] = {\n                loaded: true,\n                width:  this.width,\n                height: this.height,\n            };\n\n            callback(null, this.width, this.height);\n        };\n\n        inMemoryImage.src = imageSrc;\n    }\n\n    // Load all images and their thumbnails\n    loadAllImages(props = this.props) {\n        const generateImageLoadedCallback = (srcType, imageSrc) => err => {\n            // Give up showing image on error\n            if (err) {\n                if (window.console) {\n                    window.console.warn(err);\n                }\n                return;\n            }\n\n            // Don't rerender if the src is not the same as when the load started\n            if (this.props[srcType] !== imageSrc) {\n                return;\n            }\n\n            // Force rerender with the new image\n            this.forceUpdate();\n        };\n\n        // Load the images\n        this.getSrcTypes().forEach(srcType => {\n            const type = srcType.name;\n\n            // Load unloaded images\n            if (props[type] && !this.isImageLoaded(props[type])) {\n                this.loadImage(props[type], generateImageLoadedCallback(type, props[type]));\n            }\n        });\n    }\n\n    // Request that the lightbox be closed\n    requestClose(event) {\n        // Call the parent close request\n        const closeLightbox = () => this.props.onCloseRequest(event);\n\n        if (this.props.animationDisabled ||\n            (event.type === 'keydown' && !this.props.animationOnKeyInput)\n        ) {\n            // No animation\n            return closeLightbox();\n        }\n\n        // With animation\n        // Start closing animation\n        this.setState({ isClosing: true });\n\n        // Perform the actual closing at the end of the animation\n        setTimeout(closeLightbox, this.props.animationDuration);\n    }\n\n    requestMove(direction, event) {\n        // Reset the zoom level on image move\n        const nextState = {\n            zoomLevel: MIN_ZOOM_LEVEL,\n            offsetX:   0,\n            offsetY:   0,\n        };\n\n        // Enable animated states\n        if (!this.props.animationDisabled && (!this.keyPressed || this.props.animationOnKeyInput)) {\n            nextState.shouldAnimate = true;\n            setTimeout(\n                () => this.setState({ shouldAnimate: false }),\n                this.props.animationDuration\n            );\n        }\n        this.keyPressed = false;\n\n        this.moveRequested = true;\n\n        if (direction === 'prev') {\n            this.keyCounter--;\n            this.setState(nextState);\n            this.props.onMovePrevRequest(event);\n        } else {\n            this.keyCounter++;\n            this.setState(nextState);\n            this.props.onMoveNextRequest(event);\n        }\n    }\n\n    // Request to transition to the next image\n    requestMoveNext(event) {\n        this.requestMove('next', event);\n    }\n\n    // Request to transition to the previous image\n    requestMovePrev(event) {\n        this.requestMove('prev', event);\n    }\n\n    render() {\n        let transitionStyle = {};\n\n        // Transition settings for sliding animations\n        if (!this.props.animationDisabled && this.isAnimating()) {\n            transitionStyle = {\n                ...transitionStyle,\n                transition: ['transform', 'left', 'top', 'right', 'bottom']\n                    .map(x => `${x} ${this.props.animationDuration}ms`)\n                    .join(', '),\n            };\n        }\n\n        // Key endings to differentiate between images with the same src\n        const keyEndings = {};\n        this.getSrcTypes().forEach(({ name, keyEnding }) => {\n            keyEndings[name] = keyEnding;\n        });\n\n        // Images to be displayed\n        let images = [];\n        const addImage = (srcType, imageClass, baseStyle = {}) => {\n            // Ignore types that have no source defined for their full size image\n            if (!this.props[srcType]) {\n                return;\n            }\n\n            let imageStyle = { ...baseStyle, ...transitionStyle };\n            if (this.state.zoomLevel > MIN_ZOOM_LEVEL) {\n                imageStyle.cursor = 'move';\n            }\n\n            const bestImageInfo = this.getBestImageForType(srcType);\n            if (bestImageInfo === null) {\n                // Fall back to loading icon if the thumbnail has not been loaded\n                images.push(\n                    <div\n                        className={`${imageClass} ${styles.image} not-loaded`}\n                        style={imageStyle}\n                        key={this.props[srcType] + keyEndings[srcType]}\n                    />\n                );\n\n                return;\n            }\n\n            imageStyle.width  = bestImageInfo.width;\n            imageStyle.height = bestImageInfo.height;\n\n            const imageSrc = bestImageInfo.src;\n            if (this.props.discourageDownloads) {\n                imageStyle.backgroundImage = `url('${imageSrc}')`;\n                images.push(\n                    <div\n                        className={`${imageClass} ${styles.image} ${styles.imageDiscourager}`}\n                        onDoubleClick={this.handleImageDoubleClick}\n                        onWheel={this.handleImageMouseWheel}\n                        style={imageStyle}\n                        key={imageSrc + keyEndings[srcType]}\n                    >\n                        <div className=\"download-blocker ${styles.downloadBlocker}\" />\n                    </div>\n                );\n            } else {\n                images.push(\n                    <img\n                        className={`${imageClass} ${styles.image}`}\n                        onDoubleClick={this.handleImageDoubleClick}\n                        onWheel={this.handleImageMouseWheel}\n                        style={imageStyle}\n                        src={imageSrc}\n                        key={imageSrc + keyEndings[srcType]}\n                        alt={this.props.imageTitle || translate('Image')}\n                    />\n                );\n            }\n        };\n\n        const zoomMultiplier = this.getZoomMultiplier();\n        // Next Image (displayed on the right)\n        addImage('nextSrc', `image-next ${styles.imageNext}`);\n        // Main Image\n        addImage(\n            'mainSrc',\n            'image-current',\n            {\n                transform: `scale3d(${zoomMultiplier}, ${zoomMultiplier}, 1)`,\n                left:  -1 * zoomMultiplier * this.state.offsetX,\n                right: zoomMultiplier * this.state.offsetX,\n                top: -1 * zoomMultiplier * this.state.offsetY,\n                bottom: zoomMultiplier * this.state.offsetY,\n            }\n        );\n        // Previous Image (displayed on the left)\n        addImage('prevSrc', `image-prev ${styles.imagePrev}`);\n\n        const noop = () => {};\n\n        // Prepare styles and handlers for the zoom in/out buttons\n        const zoomInButtonClasses  = [styles.toolbarItemChild, styles.builtinButton, styles.zoomInButton];\n        const zoomOutButtonClasses = [styles.toolbarItemChild, styles.builtinButton, styles.zoomOutButton];\n        let zoomInButtonHandler    = this.handleZoomInButtonClick;\n        let zoomOutButtonHandler   = this.handleZoomOutButtonClick;\n\n        // Disable zooming in when zoomed all the way in\n        if (this.state.zoomLevel === MAX_ZOOM_LEVEL) {\n            zoomInButtonClasses.push(styles.builtinButtonDisabled);\n            zoomInButtonHandler = noop;\n        }\n\n        // Disable zooming out when zoomed all the way out\n        if (this.state.zoomLevel === MIN_ZOOM_LEVEL) {\n            zoomOutButtonClasses.push(styles.builtinButtonDisabled);\n            zoomOutButtonHandler = noop;\n        }\n\n        // Ignore clicks during animation\n        if (this.isAnimating()) {\n            zoomInButtonHandler  = noop;\n            zoomOutButtonHandler = noop;\n        }\n\n        // Clear default modal appearance\n        const modalStyle = {\n            overlay: {\n                zIndex:          1000,\n                backgroundColor: 'transparent',\n            },\n            content: {\n                backgroundColor: 'transparent',\n                border:          'none',\n                borderRadius:    0,\n                top:             0,\n                left:            0,\n                right:           0,\n                bottom:          0,\n            },\n        };\n\n        return (\n            <div>\n                <div // Floating modal with closing animations\n                    onWheel={this.handleOuterMousewheel}\n                    onMouseMove={this.handleOuterMouseMove}\n                    onMouseDown={this.handleOuterMouseDown}\n                    onTouchStart={this.handleOuterTouchStart}\n                    onTouchMove={this.handleOuterTouchMove}\n                    className={`outer ${styles.outer} ${styles.outerAnimating}` +\n                        (this.state.isClosing ? ` closing ${styles.outerClosing}` : '')\n                    }\n                    style={{\n                        transition:         `opacity ${this.props.animationDuration}ms`,\n                        animationDuration:  `${this.props.animationDuration}ms`,\n                        animationDirection: this.state.isClosing ? 'normal' : 'reverse',\n                    }}\n                >\n\n                    <div // Image holder\n                        className={`inner ${styles.inner}`}\n                        onClick={this.props.clickOutsideToClose ? this.closeIfClickInner : noop}\n                    >\n                        {images}\n                    </div>\n\n                    {!this.props.prevSrc ? '' :\n                        <button // Move to previous image button\n                            type=\"button\"\n                            className={`prev-button ${styles.navButtons} ${styles.navButtonPrev}`}\n                            key=\"prev\"\n                            onClick={!this.isAnimating() ? this.requestMovePrev : noop} // Ignore clicks during animation\n                        />\n                    }\n\n                    {!this.props.nextSrc ? '' :\n                        <button // Move to next image button\n                            type=\"button\"\n                            className={`next-button ${styles.navButtons} ${styles.navButtonNext}`}\n                            key=\"next\"\n                            onClick={!this.isAnimating() ? this.requestMoveNext : noop} // Ignore clicks during animation\n                        />\n                    }\n\n                    <div // Lightbox toolbar\n                        className={`toolbar ${styles.toolbar}`}\n                    >\n                        <ul className={`toolbar-left ${styles.toolbarSide} ${styles.toolbarLeftSide}`}>\n                            <li className={styles.toolbarItem}>\n                                <span className={styles.toolbarItemChild}>{this.props.imageTitle}</span>\n                            </li>\n                        </ul>\n\n                        <ul className={`toolbar-right ${styles.toolbarSide} ${styles.toolbarRightSide}`}>\n                            {!this.props.toolbarButtons ? '' : this.props.toolbarButtons.map((button, i) => (\n                                <li key={i} className={styles.toolbarItem}>{button}</li>\n                            ))}\n\n                            <li className={styles.toolbarItem}>\n                                <button // Lightbox zoom in button\n                                    type=\"button\"\n                                    key=\"zoom-in\"\n                                    className={`zoom-in ${zoomInButtonClasses.join(' ')}`}\n                                    onClick={zoomInButtonHandler}\n                                />\n                            </li>\n\n                            <li className={styles.toolbarItem}>\n                                <button // Lightbox zoom out button\n                                    type=\"button\"\n                                    key=\"zoom-out\"\n                                    className={`zoom-out ${zoomOutButtonClasses.join(' ')}`}\n                                    onClick={zoomOutButtonHandler}\n                                />\n                            </li>\n\n                            <li className={styles.toolbarItem}>\n                                <button // Lightbox close button\n                                    type=\"button\"\n                                    key=\"close\"\n                                    className={`close ${styles.toolbarItemChild}` +\n                                        ` ${styles.builtinButton} ${styles.closeButton}`\n                                    }\n                                    onClick={!this.isAnimating() ? this.requestClose : noop} // Ignore clicks during animation\n                                />\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nReactImageLightbox.propTypes = {\n    //-----------------------------\n    // Image sources\n    //-----------------------------\n\n    // Main display image url\n    mainSrc: PropTypes.string.isRequired,\n\n    // Previous display image url (displayed to the left)\n    // If left undefined, movePrev actions will not be performed, and the button not displayed\n    prevSrc: PropTypes.string,\n\n    // Next display image url (displayed to the right)\n    // If left undefined, moveNext actions will not be performed, and the button not displayed\n    nextSrc: PropTypes.string,\n\n    //-----------------------------\n    // Image thumbnail sources\n    //-----------------------------\n\n    // Thumbnail image url corresponding to props.mainSrc\n    mainSrcThumbnail: PropTypes.string,\n\n    // Thumbnail image url corresponding to props.prevSrc\n    prevSrcThumbnail: PropTypes.string,\n\n    // Thumbnail image url corresponding to props.nextSrc\n    nextSrcThumbnail: PropTypes.string,\n\n    //-----------------------------\n    // Event Handlers\n    //-----------------------------\n\n    // Close window event\n    // Should change the parent state such that the lightbox is not rendered\n    onCloseRequest: PropTypes.func.isRequired,\n\n    // Move to previous image event\n    // Should change the parent state such that props.prevSrc becomes props.mainSrc,\n    //  props.mainSrc becomes props.nextSrc, etc.\n    onMovePrevRequest: PropTypes.func,\n\n    // Move to next image event\n    // Should change the parent state such that props.nextSrc becomes props.mainSrc,\n    //  props.mainSrc becomes props.prevSrc, etc.\n    onMoveNextRequest: PropTypes.func,\n\n    //-----------------------------\n    // Download discouragement settings\n    //-----------------------------\n\n    // Enable download discouragement (prevents [right-click -> Save Image As...])\n    discourageDownloads: PropTypes.bool,\n\n    //-----------------------------\n    // Animation settings\n    //-----------------------------\n\n    // Disable all animation\n    animationDisabled: PropTypes.bool,\n\n    // Disable animation on actions performed with keyboard shortcuts\n    animationOnKeyInput: PropTypes.bool,\n\n    // Animation duration (ms)\n    animationDuration: PropTypes.number,\n\n    //-----------------------------\n    // Keyboard shortcut settings\n    //-----------------------------\n\n    // Required interval of time (ms) between key actions\n    // (prevents excessively fast navigation of images)\n    keyRepeatLimit: PropTypes.number,\n\n    // Amount of time (ms) restored after each keyup\n    // (makes rapid key presses slightly faster than holding down the key to navigate images)\n    keyRepeatKeyupBonus: PropTypes.number,\n\n    //-----------------------------\n    // Image info\n    //-----------------------------\n\n    // Image title\n    imageTitle: PropTypes.node,\n\n    //-----------------------------\n    // Other\n    //-----------------------------\n\n    // Array of custom toolbar buttons\n    toolbarButtons: PropTypes.arrayOf(PropTypes.node),\n\n    // Padding (px) between the edge of the window and the lightbox\n    imagePadding: PropTypes.number,\n\n    // When true, clicks outside of the image close the lightbox\n    clickOutsideToClose: PropTypes.bool,\n};\n\nReactImageLightbox.defaultProps = {\n    onMovePrevRequest: () => {},\n    onMoveNextRequest: () => {},\n\n    discourageDownloads: false,\n\n    animationDisabled:   false,\n    animationOnKeyInput: false,\n    animationDuration:   300,\n\n    keyRepeatLimit:      180,\n    keyRepeatKeyupBonus: 40,\n\n    imagePadding:        10,\n    clickOutsideToClose: true,\n};\n\nexport default ReactImageLightbox;\n\n\n/** WEBPACK FOOTER **\n ** ./src/react-image-lightbox.js\n **/","/**\n * Get the version of Internet Explorer in use, or undefined\n *\n * @return {?number} ieVersion - IE version as an integer, or undefined if not IE\n */\nexport function getIEVersion() {\n    const match = navigator.userAgent.match(/(?:MSIE |Trident\\/.*; rv:)(\\d+)/);\n    return match ? parseInt(match[1], 10) : undefined;\n}\n\n/**\n * Placeholder for future translate functionality\n */\nexport function translate(str, replaceStrings = null) {\n    if (!str) {\n        return '';\n    }\n\n    let translated = str;\n    if (replaceStrings) {\n        Object.keys(replaceStrings).forEach(placeholder => {\n            translated = translated.replace(placeholder, replaceStrings[placeholder]);\n        });\n    }\n\n    return translated;\n}\n\n\nexport function getWindowWidth() {\n    return window.innerWidth ||\n        document.documentElement.clientWidth ||\n        document.body.clientWidth;\n}\n\nexport function getWindowHeight() {\n    return window.innerHeight ||\n        document.documentElement.clientHeight ||\n        document.body.clientHeight;\n}\n\n// Returns true if this window is rendered as an iframe inside another window\nexport function isInIframe() {\n        try {\n            return window.self !== window.top;\n        } catch (e) {\n            return true;\n        }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/util.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"react\"\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}